<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[六、进程互斥]]></title>
      <url>%2F2017%2F02%2F22%2Fthread3%2F</url>
      <content type="text"><![CDATA[进程的互斥 是指当有若干个进程都要使用某一个资源时，任何时刻最多只允许一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占有者释放了该资源。一般来说，当 n 个进程 P1, P2,…,Pn要共享某一资源时，为保证资源的互斥使用，首先应找出 n 个进程各自的临界区，然后对每个进程的临界区使用PV操作。进程Pi(i=1，2，….,n)互斥一般形式如下所示：1234567891011121314151617begin S: semaphore ； S: = 1 ; ...cobegin ... process Pi begin ... P (S) ; 临界区 i V (S) ; ... end; ...coend ;end; 由于自身或外界原因，进程执行时会随时被中断。如果一个已进入临界区的进程，在临界区执行的过程中断，能否保证其共享资源的互斥使用呢？回答肯定是的，因为一个进程在临界区执行虽然被中断，但它在临界区的操作并没有完成，因而不会去调用V(S) 。假设当一个进程A 在临界区执行时被中断，另一个进程B 如果也要进入临界区，则一定先调用P(S) ，但此时被中断的进程A 尚未退出临界区，S 的值任然为 0 ，所以当进程进入临界区的进程B 调用P(S)的结果必然是等待。只有当被中断的进程A 再次占用处理器，完成临界区的操作后，调用了V(S)操作，才允许其他进程进入临界区。显然，共享资源的情况，保证了资源互斥使用。 并发进程使用共享计数器 下面我们举个例子，例子中两个并发进程都要使用共享的计数器count .从分析中看到，只有当一个进程不使用count时，另一个进程再去使用，才不会出现错误。如果它们交叉的使用count,则会出现时间相关的错误。为了保证两个进程互斥的使用计数器，可以用PV操作来进行管理。定义一个信号量S ，S的初始值为1 。如下所示： 1234567891011121314151617181920212223242526begin count : integer ; S : semaphore ; count:= 0 S: =1 cobegin process PIN R1: integer ; begin P (S); R1:= count ; R1:= R1 +1 ; count:= R1 ; V (S) end; process POUT R2： integer ; begin P (S) ; R2:= count ; R2:= R2-1 ; count:= R2 ; V (S) end ; coend;end 因为这里的P(S) 限制了一次只有一个进程在临界区执行，所以改写后的程序即使被中断，也不会出现两个进程同时进入临界区访问count,这就保证了进程互斥使用共享计数器。 有点要提醒的是：PV操作是一种可以实现进程互斥的进入相关临界区的工具，但只有合理使用该工具，才能保证进程的并发性，又避免交叉使用导致出错，在解决具体问题时，应该考虑场景是否需要使用PV来管理临界区。粗心使用PV操作可能会违反对临界区的管理要求。如下所示： 1234567891011121314151617181920begin S : semaphore ; S :=1 ; cobegin process Pi (i=1,2,3...,n) begin //按旅客订票要求找到AK; P(S) ; Ri= Ak ; if Ri &gt;= 1 then begin Ri:= Ri -1; Ak: =Ri ; V(S) ; print("输出一张票") end else print("票已售完") end ; coend ;end ; 进程执行调用P(S)判定是否能进入临界区。由于S 的初始值为1，故每次只能有一个进程进入临界区，其他进程进入临界区执行的进程必须等待，这符合临界区管理第一点要求。但在改写的程序中，忽略了当条件Ri&gt;=1不成立时执行的else 部分的V操作，以致使进程在临界区中判断别的条件R1&gt;=1 不成立时无法退出临界区，当然也就不能释放等待进入临界区的进程，造成进程无限等待进入临界区，这就违反了对临界区管理的第二、第三两个要求。正确的做法应该如下： 12345678910111213141516171819202122begin S : semaphore ; S :=1 ; cobegin process Pi (i=1,2,3...,n) begin //按旅客订票要求找到AK; P(S) ; Ri= Ak ; if Ri &gt;= 1 then begin Ri:= Ri -1; Ak: =Ri ; V(S) ; print("输出一张票") end //没有票的时候 也退出临界区。 V(S)； else print("票已售完") end ; coend ;end ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五、临界区与PV操]]></title>
      <url>%2F2017%2F02%2F22%2Fthread2%2F</url>
      <content type="text"><![CDATA[临界区我们把并发进程中与共享变量有关的程序段称之为临界区。在上文例子中有讲到n个P的并发进程的临界区是1234r = ak ;if( r &gt;= 1)&#123; r = r - 1; ak = r; 如果能够保证一个进程在临界区执行时，不但另一个进程进入相关的临界区执行，即各进程对共享变量的访问是互斥的，那么就不会造成与时间有关的错误。相关临界区是指并发进程中涉及到相同变量的临界区。例如上面的例子进程p1,p2,…pn 都要访问变量ak ,所以他们的临界区是相关的.对于共享变量若干临界区必须是互斥执行的，而对于不同的变量的临界区的执行是不需要互斥的。对于若干个并发进程共享某个变量的相关临界区的管理有三个要求：1、一次最多一个进程进入临界区。当有进程在临界区执行时，其他想进入临界区必须等待；2、不能让一个进程无限制的在临界区执行，即任何一个进入临界区的进程必须在有限的时间内退出临界区；3、不能强迫一个进程无限制的等待进入它的临界区，即有进程退出临界区时应该让一个进程进入临界区; PV操作为了实现对临界区的管理要求，必须做到；当无进程在临界区时，若有进程要进入临界区，则允许一个进程立即进入到它的临界区；当有一个进程在临界区执行时，其他试图进入临界区的进程必须等待；当有一个进程离开临界区时，若有等待进入到临界区的进程，则允许其中一个进入到它的临界区。Dijkstra 发明了PV操作能够实现对临界区的管理要求。PV操作是由两个操作-P操作和V操作组成的，它们两个不可中断的过程，通常把这种不可中断的过程称为原语。因此，P操作和V操作也可称为P操作原语 和V操作原语，简称为PV操作。PV操作对信号量的操作，它们的定义如下： P操作P(S):将信号量S 减去1 ，若结果小于0 ，则把调用P(S) 的进程设置成等待信号量S的状态。 V操作V(S):将信号量S 加1，若结果不大于等于0，则释放一个等待信号量S的进程。这两个操作可表示如下两个过程。 Procedure P (Var S: Semaphore ); begin S: = S - 1; if S &lt;0 then W (S) end; { P } Procedure P (Var S: Semaphore ); begin S: = S + 1; if S &lt;= 0 then R (S) end; { V } 其中W(S) 表示把调用P(S)的进程设置成等待信号量S的状态，R(S)表示释放一个等待信号量S的进程。信号量S的初始值为0或1或其他的整数，它应该在系统初始化时确定。分析下PV操作的两个过程。当信号量S的初始值为1时，如果若干个进程都调用了P操作，则只有一个调用P操作的进程不会成为等待状态，而可以继续执行下去。P操作被调用一次后，S的值会设置为0，以后的进程调用P操作的时候，当P操作执行S:=S-1后，S的值总是小于0，所以调用者就被置成等待状态而不能够继续执行，直到有进程调用V操作后才会被释放一个等待者。 因此，若干个PV操作管理进程互斥的进入临界区，则只要用一个信号量与一组设计到共享变量的相关临界区联系起来，该信号量的初始值定为1.任何一个进程，当要进入临界区时，先要调用P操作，以确是进入临界区还是等待进入。当执行临界区的操作后，退出临界区时调用V操作，以释放在等待进入临界区的诸进程中的一个（如果有的话）。由于信号量的初始值为1，因此P操作起到了“一次只允许一个进程进入临界区，其余欲进入者必须等待”的限制作用。由于任何一个进程退出临界区都调用V操作，故当有进程在等待进入临界区时，V操作释放一个进程，使它可以进入临界区执行，因此而不会出现“进程无限制的留在临界区或者无限的等待进入临界区”的情况。所有，PV操作完全能够符合对临界区管理的三个要求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[四、并发进程概念，以及遇到的一些常规问题！]]></title>
      <url>%2F2017%2F02%2F19%2Fthread1%2F</url>
      <content type="text"><![CDATA[进程的顺序性进程的顺序性是指进程在顺序处理器上执行是严格按序的，即按照规定的操作顺序，在前一个操作执行完后，才能执行以一个操作。当一个进程独占处理器顺序执行时，它具备两个特性：1、封闭性–&gt;进程执行的结果只取决于进程的本身，不受外界影响。也就是说，进程执行的结果与其执行的速度无关。2、可再现性–&gt;进程重复执行时，必须获得同样的结果。也即，只要初始条件相同，则无论在什么时间执行都产生同样的结果。 进程的并发性在多道程序设计的系统中会同时存在着许多个进程。每个进程都具有顺序性，在单处理器的情况下，这些进程要竞争处理，能占用多长时间，这不仅取决于进程的自身，还取决于进程的调度策略（第二章 【进程的概念】中有讲到调度策略）。例如：有两个进程A 和B,他们的顺序执行的操作例如下：1、进程 A：a1, a2, a3, a4,…,an2、进程 B：b1, b2, b3, b4,…,bn在多道程序设计系统中，处理器会交替执行它们的操作。处理器可能序列：1、a1, b1, a2, b2, a3, b3, ….执行这些操作，也可能按序列：1、a1, a2, b1, b2, b3, a3, … 执行这些操作，还可能按照其他的序列来执行。也就是说，在一个进程的工作还没全部完成之前，另一个进程就可以开始工作了，我们说这些进程是可同时执行的，或者它们具有一定的并发性，并且可把同时执行的进程称之为并发执行过程。 并发进程相互之间可能是无关的，也可能是交互的。例如，为两个不同的源程序进行编译的两个进程，它们可以是并发，但是它们之间却是无关的。因为两个进程分别为不同的源程序进行编译，也就是分别在不同的数据集合上运行，因此一个进程的执行是不会影响另一个进程的执行，一个进程的执行与另一个进程的进展无关，它们是各自独立的，又如：计算一个问题中的输入进程，处理进程，输出进程是三个并发进程，其中每一个进程的执行都依赖另一个进程的进展情况。只有当输入进程把一批数据读取后，处理进程才能对它加工，输入进程才能读下一批数据。可见，它们是一组有交互的并发程序。有交互的并发程序一定就有共享某些资源.例如上例中的输入数据是输入进程与处理进程的共享资源，输出数据 是处理进程与输出进程的共享资源，存放数据的工作区是这些并发程序的共享资源。进程并发执行时，执行结果与其执行相对于的速度有关。在上例中，如果输入进程尚未把一批数据全部读入，处理进程就对其进行加工的话，那么其结果就会出错。因此，进程的并发执行就会被破坏封闭性 和可在现性。 与时间有关的错误一个进程运行时，经常会由于自身或外界的原因而被中断，且中断点是不固定的。一个进程被中断后，那个进程可以运行呢？被中断的进程什么时候能再去占用处理器呢？这是与进程调度策略有关的。所以，进程执行的相对速度不能由进程自己来控制的，于是，就可能导致并发进程在共享资源时出现错误。看下面例子。设置一个飞机航班售票系统有N个售票处，每个售票处理通过终端访问系统的公共数据区。假定公共数据区中的一些单元ak分别存放余票数。设置p表示各售票处的处理进程， r 表示各个进程执行时所需要的工作单元。当各售票处有旅客购买票时，进程如下工作执行:1234567891011121314int ak =n;int p=nfor (int i =0;i&lt;p ;i++ ) &#123; //按旅客订票要求找到ak r = ak ; if( r &gt;= 1)&#123; r = r - 1; ak = r; print(“输出一张票”) &#125;else&#123; print("票已卖完") &#125;&#125; 由于各售票处旅客订票的时间以及要订的机票日期和航班都是随意的，因此可能有若干个旅客在几乎相同的时间里到不同的售票处，要求购买同一天同一航班的机票，于是若干个进程都要访问一个ak,进程发执行时，可能会出现如下的情况： 进程Pi和Pj分别在时刻t1和t2取到相同的值AK ,当ak &gt;=1 时，都认为还有票可售给旅客。于是各自执行票余数减少1的操作，然后把当前的票余数存回ak.显然，这两个进程共售出同一天同一航班的机票两张，ak的值应该减少2，但实际上ak的值只减去了1，产生错误。特别是，若当这两个进程执行前ak=1,它们并发执行后，则将发生把唯一的一张机票卖给了两个旅客的错误。这个错误也就是进程交替访问了共享变量AK而造成的与时间有关的错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[方向]]></title>
      <url>%2F2017%2F01%2F18%2Ftrues%2F</url>
      <content type="text"><![CDATA[45岁如何合理退休。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[127.0.0.1和0.0.0.0之间的区别]]></title>
      <url>%2F2017%2F01%2F10%2Fnetwork1%2F</url>
      <content type="text"><![CDATA[我们大多数人听说过’127.0.0.1和0.0.0.0’，但是可能对他们太多的思考，但如果两者实际上似乎指向相同的位置，那么两者之间的实际差异是什么？ 127.0.0.1和0.0.0.0之间的区别是什么 127.0.0.1是环回地址（也称为localhost）。 0.0.0.0是用于指定无效，未知或不适用目标（“无特定地址”占位符）的不可路由元地址。在路由条目的上下文中，它通常意味着默认路由。 在服务器方面，0.0.0.0表示在本地机器上所有的IPv4地址。如果主机有两个IP地址127.0.0.1和10.1.2.1，并且主机上运行的服务器在0.0.0.0上侦听，则在这两个IP上都可以访问。 什么是IP地址127.0.0.1？127.0.0.1是环回因特网协议（IP）地址也被称为本地主机。该地址用于建立到终端用户正在使用的同一机器或计算机的IP连接。 对于使用:: 1的内涵支持IPv6寻址的计算机定义了相同的约定。使用地址127.0.0.1建立连接是最常见的做法; 但是，使用127 … 范围内的任何IP地址将以相同或类似的方式工作。环回结构给予能够联网的计算机或设备以在机器上验证或建立IP堆栈的能力。 特殊地址A类网络号127被分配了环回功能，即通过一个更高级别的协议发送数据报给网络127的地址应环回主机内。没有数据包发送到网络127的地址应该永远出现在任何网络上的任何地方。 wiki:http://www.howtogeek.com/225487/what-is-the-difference-between-127.0.0.1-and-0.0.0.0/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三、进程控制块]]></title>
      <url>%2F2017%2F01%2F08%2Fsystem3%2F</url>
      <content type="text"><![CDATA[进程控制块运行变化在计算机系统中，尤其是在多道程序设计系统中，往往是有许多不同的进程同时存在系统中。为了区分各个不同的进程，记录各个进程执行的情况，对每个进程都设置一个程序控制块（Process Control Block,缩写为PCB）。这次好比多次列车发时，为了保证列车行驶的安全，在每次列车始发时调度室就为该列车建立管理信息，记录该列车的车次、列车号、状态（行驶或停站）、目前从哪站出发正在行驶或停在什么地方，等等。调度室根据记录的情况进行调度且随者列车运行情况的变化不断地修改管理信息。当列车到达终点后，调度室就撤销该列车的管理信息。在计算机系统中，进程控制块就是对进程进行管理和调度信息集合。它包含四类信息： 标示信息。用于标示一个进程。 说明信息。用于说明进程情况。 现场信息。用于保留当前运行进程暂时让出处理器时存放在处理器中的各种信息，以便能继续运行时得以恢复. 管理信息。用于管理进程信息。最基本的进程控制块如下所示： 可以把程序看作是一个静态的实体，程序可作为软件资料长期保存。而进程是程序在一个数据集上执行的过程，可看作是一种动态的实体。每个进程都有自己的生命周期，即从创建到销毁。为了完成一项工作，首先要为某一个程序分配工作区（存放程序执行的数据）和建立一个进程控制块。这时就说创建一个进程。一个被创建的进程是由它的进程控制块中的进程名来标识的。进程刚被创建时，它的初始状态为就绪态.当它能够占用到处理器时就变成运行态当它在运行态过程中受到外部影响（如外存IO请求。）,状态可不断发生变化。进程执行时，把不断发生变化的情况都记录到程序控制块中。操作系统依据程序控制块对进程进行控制和管理。一个进程在执行过程，为了请求某个服务，可以再要求创建其他进程。例如，一个作业被接受到系统后，首先对源程序进行编译。于是系统为该作业创建一个能够编译任务的进程。编译进程工作中要请求系统启动外围设备（IO），把源程序读入主存储器。于是系统又要创建一个读程序的进程。读源程序时又可能发现分配的主存空间不够大，而要求再创建一个分配主存空间的进程来扩充主存区域，如此等等，各进程相互协作，完成一个特定的计算任务。每创建一个进程都要有一个进程控制块来标识当前进程。这时是该进程的生命周期的开始。一个任务完成自己的任务后，系统要回收这个进程占用的工作区（内存） 以及撤销该进程的控制块，这时该进程就结束它的生命而消亡。因此，每个进程都有一个从创建到消亡的生命周期。操作系统中往往设计一些能完成特定功能且不可中断的过程。这些不可中断的过程称之为原语.用来控制进程的原语有： 创建原语。为了程序分配一个工作区和创建一个进程控制块，并置该进程为就绪态 撤销原语。一个进程完成工作后，收回它的工作区和进程控制块。 阻塞原语。进程运行过程中发生等待事件时，把进程状态改成等待态。 唤醒原语。当进程等待的事件发生时，把进程的状态改为就绪态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随手笔记]]></title>
      <url>%2F2017%2F01%2F05%2Fthread%2F</url>
      <content type="text"><![CDATA[redis 单内存块，单线程读写。 因redis 单内存块，所以单线程执行还会比较合适，那么如果使用多线程呢？ 我们都知道线程其实就是cpu虚拟出来的，并且同一时间cpu只能处理一个请求 ，假设是使用多线程的话，读写一个内存块，还会有上下文切换的问题。占用没必要的资源。 要想执行效率提升，首先保证事物之间没有相关性，并行执行 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二、进程的概念]]></title>
      <url>%2F2016%2F12%2F27%2Fsystem2%2F</url>
      <content type="text"><![CDATA[背景说明对于多道并行执行的程序来说，有时候它要占用处理器（单核）的运行，有时候要等待传送的信息，当得到信息后又可以继续执行，一个程序能受到另一个程序的约束。所以，程序的执行实际上是走走停停的，为了能够正确反映程序执行的活动规律以及状态，我们要引进新的概念–进程，以便从变化的角度，动态的分析程序运行的状态。 进程的定义我们都知道计算机为了解决某些业务问题，首先必须会编写程序代码，可把程序代码看作是具有独立功能的一组指令集合，或者说是指出处理器执行操作的步骤。程序执行必须依赖于一个实体–数据集。把一个程序在一个数据集上的一次执行称之为一个进程（Process）.可用一个铁路交通管理的例子来比如程序和进程。为了对比说明，首先区分火车和列车。火车是一种可以载人的交通工具，而列车是指已经从某起点出发但是还没有到达终点站得正在行驶的火车。对于火车而言，它是静止的，它具有运输人或货物的功能。对列车而言，它是动态的，除了火车本身以外，还包括了人或物，要把人或物送到目的地。显然，可以把火车比作程序，把列车比作进程，列车中的人或物看作程序执行的数据集。 为什么要引入进程提高资源利用率操作系统把一个计算问题中每个独立执行的程序模块看作一个进程，例如，输入进程、处理进程、打印进程。通过进程同步可使这些进程正确合作，从而使处理器与外围设备之间有效的并行工作，提高资源利用率。 进程的属性1、进程是动态的，他包含了数据和运行在数据集上的程序。2、多个进程可以含有相同的程序进程与进程并非是一一对应的。一个程序运行在不同的数据集上就构成不同的进程，分别得到不同的结果。对不同的进程，可用不同的进程名来区分。这好比同一列火车在不同的时候可以有不同的车次一样。例如一列火车从上海开往北京时，称为Z14次列车，把上海的旅客送往北京；当这一列火车从北京返回时，它被称为Z13次列车，把北京的旅客送往上海。 多进程并发执行若干个进程是可以同时执行的，即一个进程已经开始工作但是还没有结束之前，另一个进程也可以开始工作。把这些进程称之为是同时执行的进程,或者称之为进程的并发执行.这正像不同车次的列车可以同时运行一样。必须强调的是，同一列火车是不能同时即作为Z14次列车又作为Z13次列车运行的，但同一个程序是可以同时在不同数据集上运行构成不同的进程的，例如，在多道程序设计系统中，编译程序可以同时对若干个用户的源程序进行编译，即使一个编译程序可同时被多个用户调用，构成多个可同时执行的进程。 进程的基本状态一个进程在占用处理器运行的过程中，可能由于某些原因要占时让出处理器。例如，一个正占有处理器运行的进程P1启动一个设备后，往往要等到外围设备传输完信息才能再运行，于是P1启动了外围设备后应让出处理器。这时另一个进程P2可能占有处理器运行。当P1启动的外围设备完成了传输工作后，可能要暂停P2的运行，让P1继续运行下去，所以，对一个单核处理器的系统来说，若干个进程是轮流占用处理器的运行，一个进程运行若干条指令后，由于自身的原因（例如，有高优先级的进程要运行）让出处理器，然后别的进程可以占用处理器。为了便于管理进程，我们按进程在执行过程中不同时刻的不同情况定义三种不同的基本状态： 等待态 等待某一事件 就绪态 等待系统分配处理器以便运行； 运行态 正在占有处理器运行。进程在执行过程中不断发生状态变化，进程的转换图如下所示： 运行态–&gt;等待态一个进程运行中启动了外围设备，等待外围设备传输结束；进程在运行中申请资源（主存空间，外围设备）得不到满足，变成等待分配资源状态；进程在运行中出现了故障（程序错，主存错误），变成等待排除干预状态。 等待态–&gt;就绪态外围设备工作结束，使等待外围设备传输者结束等待；等待资源得到满足（另一进程归还）；故障排除后等待干预的进程结束等待。一个结束等待的进程必须转换成就绪态，当分配到处理器后才运行。 运行态–&gt;就绪态分配给进程占用处理器的时间用完而强迫进程让出处理器；有更高优先级的进程要运行，迫使当前运行进程让出处理器。 就绪态–&gt;运行态有多个进程等待分配处理器时，系统按一种规定的策略（进程提供了两种优先级，一种是普通的进程优先级，第二个是实时优先级。前者适用SCHED_NORMAL调度策略，后者可选SCHED_FIFO或SCHED_RR调度策略。任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占，同级实时进程之间是按照FIFO（一次机会做完）或者RR（多次轮转）规则调度的。），从多个处于就绪态的进程中选择一个进程，让他占用处理器，被选中的进程就变成运行态。 根据上述四个基本属性可概括为进程具有如下三个特性： 动态性 进程是程序一次性执行的过程，在执行过程中状态不断变化。 并发性 若干个进程是可同时被执行的，它们轮流占用处理器交替执行 异步性 进程的执行速度取决于自身与外界原因以及进程调度策略，因此可以不可预知的速度向前推进。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一、处理器的工作状态]]></title>
      <url>%2F2016%2F12%2F14%2Fsystem1%2F</url>
      <content type="text"><![CDATA[背景说明任何一个程序必须占用处理器后才能执行，而在一个计算机系统中往往同时存在多个程序，即系统程序，又有用户程序，他们都要占用处理器让处理器按自己的要求执行指令，以完成各自的任务。由于计算机系统中的资源是由操作系统统一管理的，任何一个用户程序都不能擅自改变资源的使用情况，因此，处理器应有不同的工作状态，以区分当前执行的指令是操作系统的还是用户程序的。 特权指令 为了保证计算机能够可靠的运行，经常会把 CPU 执行的命令分成两类，特权指令 and 非特权指令 把不允许用户程序直接使用的指令称为 特权指令，其余的为 非特权指令 。例如：设置时间／设置控制寄存器等都是特权指令（ 一般root权限 拥有特权指令,普通用户权限 拥有非特权指令 ）。 管态和目态 为避免用户程序中错误的使用 特权指令，计算机硬件结构中的中央处理器具有两种工作状态：目态 and 管态。当中央处理器处于目态时，不允许执行特权指令；当中央处理器处于管态时，可执行一切指令。所以当操作系统占用中央处理器时，应让中央处理器在管态工作；当用户程序占用中央处理器时，应当让中央处理器在目态工作。如果在目态的情况下执行特权指令，中央处理器会拒绝执令，并且会被捕捉 形成一个程序中使用非法指令。硬件的中断装置识别到该信号后，将暂停用户执行的指令，并转交给操作系统去处理。操作系统再通知用户：程序中有非法指令。PS:比如我用普通用户修改 时间，就会提示没权限。1234Me ~date -s '20160101'date: cannot set date: Operation not permittedFri Jan 1 00:00:00 CST 2016Me ~ 程序状态字 CPU 怎样确定当前程序是按照目态指令执行，还说管态指令执行？又怎样保证交替不同状态程序服务不出差错？程序状态字起了关键作用。程序状态字（Progran Status Word）,缩写为 PSW是用来控制指令执行顺序，并且保留程序指示与程序有关的系统状态。例如：单核CPU执行多线程，站在用户角度看貌似是并行的，其实只是CPU切换处理多个线程，切换的太快才让用户无感体验。比如a线程执行到3的时候，切换到b线程执行到4，这个时候又切换到a线程。要保证a线程从第3开始执行？这就需要通过 PSW寄存器 把线程的 执行的位置给记录下来 方便下次执行。 程序基本状态1、中断屏蔽位 –&gt; 指出程序执行中发生中断事件时，要不要响应出现的中断事件。2、目态 –&gt; 当设置为目态时，程序执行时不可使用特权指令。3、管态 –&gt; 当设置为管态时，程序可执行一切指令，包括特权指令。4、中断码 –&gt; 保存程序执行当前发生的中断事件。5、条件码 –&gt; 指出指令执行结果的特征。6、指令地址 –&gt; 指出吓一条指令的内存地址。 程序状态字的格式如下图所示： 每个程序都要有一个程序状态字（PSW）来刻画程序执行的状态。显然，在系统用户PWS 状态位设置为管态，在非系统用户 PWS 状态位应设置为目态。 在单核处理器系统中，整个系统会设置一个寄存器来保存运行时程序状态字（PSW）,顾名思义 该寄存机也就叫PSW寄存机。处理器总是按照PSW寄存机的指令地址来控制程序运行，所以，当系统调度到某个程序运行时，必须要把该程序的PSW送到PSW寄存机中，这个时候处理器就控制该程序执行了，同样，当某个程序暂时让出处理器，必须要把该程序的PSW保存好，一旦它能够执行，又可把它的PSW丢到PSW寄存机中。 系统调用 操作系统编制了许多不同功能的子程序（例如，读写文件子程序，分配主存子程序，启动I/O子程序），这些操作系统提供的子程序称之为系统功能调用程序，简称：系统调用。 那如何调用系统子程序呢？操作系统中有一条访管指令，这是一条在目态下执行的指令，只要设置一些参数，如设备号，交换信息的主存起始地址，要交换的信息的长度等。当处理器在目态下执行一条访管指令会导致产生中断事件，中断装置会把当前PSW寄存器已有的用户PSW保存起来，再把系统的程序状态字（PSW）放入PSW寄存器中，那么当前系统状态为管态了，当然，在管态下执行访管指令也顺理成章，完成一次系统调用后，操作系统把用户程序的PSW放入，PSW寄存器中。那么当前处理器又返回目态环境执行用户程序了。 PS：图片来自于 计算机组成原理教程 第九章 9.5.3 通道的工作过程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GC导致系统卡顿,分析过程.]]></title>
      <url>%2F2016%2F12%2F08%2Fgc%2F</url>
      <content type="text"><![CDATA[问题背景xx日项目上线新功能，当时还比较顺利，第二天早上发现当用户量上来，系统整体做交易比较慢，严重一点直接访问超时，必须要重启系统 才能暂时恢复正常，由于这次上线跟多个系统有对接关系，回退相当困难，只能在线上分析问题了，唉 不说多了，下面来一起分析问题吧。 系统背景 整体使用 ESB架构 实现分布式部署，以及实现前后端分离（此文分析前端系统），前端系统 使用 WEB 服务器 对应一台 AP服务器 , 采用直连方式访问。在异地也配置两台备机AP。再通过网络层实现负载均衡以轮训的访问访问3台AP 。 基础软件方面采用 WEB服务器、AP服务器、DB服务器的操作系统环境均采用RedHad5.8 ,数据库采用Oracle10.2.0.4 ,中间件采用Weblogic 10.3.5,WEB服务器采用Apache 2.0 系统配置 WEB配置：2核CPU ，4G物理内存，300G硬盘内存 AP配置：4核CPU ， 16G物理内存，600G硬盘内存 DB配置：4核CPU，32G物理内存，600G硬盘内存 当时分析点 查看日志是否有死锁，异常交易。 代码有死循环代码块，导致整个系统运行缓慢。 数据库连接不够，导致有连接竞争，阻塞(Blocked)。 数据库 有锁表的的问题。 调用其他系统接口，可能有定时任务。导致响应缓慢，占用连接资源拖慢系统。 服务器运行内存，CPU不够。 我们围绕着这5个点，逐步排查 系统大部分交易日志都运行正常，非正常的就是访问超时。 我们对新上线的功能进行Code Review，并没发现有死循环，非正常消耗资源的代码。 有时候连接数不够用，我们把连接池数也加大。 改完后我们运行，体现不出效果。当系统运行缓慢的时候，有很多连接都是空闲状态的。所以这点可以排除点了。 数据库锁表问题，如果一旦锁表会导致修改删除，不能操作。但是我们系统流程可以正常运行，这点也可以排除掉。 我们有跟其他系统的接口人，一起测试过，他们响应都是毫秒级（不过一旦系统缓慢，我们这边监控到响应速度也是10几秒的）。 后来我们通过top命令，查看服务器使用资源有时候CPU会彪到300~400（我们系统4核），怀疑点指向了硬件配置。 最终决定解决方案： 调大CPU，把现有4核调整到8核，调优之后确实好转很多。系统运行时间 是之前的倍数，才会导致系统慢下来，这也算是治标不治本，权宜之计罢了。 搭建测试环境 我们在本地通过Jmeter压测，同时通过Java Viratul 、Jconsole远程监控线程，发现有日志阻塞（Blocked）， 还有极少的Weblogic阻塞现象，但并没有有死锁（Deadlock） 。 CPU跑的极度不稳定时高时低，Weblogic没有异常现象。 这个时候疑问来了，因为跑的并发数也只有少数个，为什么会导致CPU这么不稳定呢？会不会是跑通信（netty）服务端（提供接口方）跑的流程太多，导致低并发高耗时的问题，为了验证这个问题我们把挡板（屏蔽服务端通信，本地通信）搭建来。测试结果也是一如既往。 我们再从一个最简单的交易压测试试 ，CPU平均70%，CPU幅度还是比较大，压测（Jmeter）20几分钟左右停止 压测工具后，问题又出现了Weblogic又异常的卡。我们再通过jstat 看看GC回收情况。 压测工具（Jmeter）聚合结果，少数个并发，平均响应10秒以上(测试登陆交易聚合报告) 少个并发，压测了26多分钟导致发生Full GC发生数5678次，耗时5017.323秒，相当吓人啊。目测应该是程序某个地方触发了GC。全局搜索了下代码 程序中真有地方频繁调用System.gc() 。我们再把代码中调用系统垃圾回收(Full GC)去掉，同样的并发数，同样的测试时间，测试结果如下所示：CPU使用率相对稳定 Java 虚拟机回收也比较稳定 Full GC(Mark-Sweep、标记-清除)触发0次 ，Minor GC触发68次。 少数个并发，压测了26多分钟导致发生Full GC发生数0次，耗时0秒，CPU使用相对稳定，日志打印正常。 压测中之所以CPU使用率幅度大，是因为Java虚拟机垃圾回收器机制所导致，我们使用的是Parallel GC 并行回收，如我们使用了8核CPU 那么我们会有8个线程来做回收这件事情，频繁触发 肯定会有8个线程一直在消耗CPU的资源，那么可能会导致 用户具体交易线程获得不到CPU使用权。目测JVM应该有设置线程使用CPU优先级。 实用排查方法以及命令查看消耗CPU 最高的线程 使用命令top -p ，显示你的java进程的内存情况，pid是你的java进程号，比如123 按H，获取每个线程的内存情况 找到内存和cpu占用最高的线程pid，比如15248 执行 printf 0x%x 15248 得到 0x3b90 ,此为线程id的十六进制 执行 jstack 123|grep -A 10 3b90，得到线程堆栈信息中3b90这个线程所在行的后面10行 查看对应的堆栈信息找出可能存在问题的代码 Linux JVM 常用命令 jstat gcutil pid 可实时查看JVM 内存运行情况 jmap pid 查看JVM内存配置 jstack pid 查看堆栈信息 JVM 常用自带工具1、jinfo2、jconsole3、jvisualvm4、jstat5、jmap6、jps7、jhat8、jstat 统计线程运行状态 通过jstack pid 重定向到dump，再通过grep 统计线程状态[weblogic@gzmbsap01 ~]$jstack 29957 &gt; /home/mw/weblogic/dump[weblogic@gzmbsap01 ~]$grep java.lang.Thread.State dump | awk ‘{print $1$2$3$4$5}’ | sort | uniq -c]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-next]]></title>
      <url>%2F2016%2F12%2F03%2Fnext-md%2F</url>
      <content type="text"><![CDATA[rebby hexo-next 语法笔记.. 使用 Hexo 生成静态文件快速而且简单。1$ hexo generate 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。1$ hexo generate --watch 代码高亮设置3个反斜杠加想要设置的变成语言,比如【3反斜杠+java 代码体 3反斜杠结束】就呈现效果如下所示： 12345678public class MainActivity extends AppCompatActivity &#123; @Override public void onCreate() &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 加载图片1![img](xxx/xxx.jpg) 图片设置百分比123&lt;center&gt;&lt;img src=&quot;/images/process_control.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/center&gt; 分类设置创建 hexo new page categories 目录引用到生成的categories／index.md目录设置type类型指向。 12345---title: 分类date: 2016-12-14 15:33:13type: "categories"--- 路径配置到你对应的主题（next）配置目录路径。 12345678 menu:home: /archives: /archivescategories: /categoriestags: /tagsabout: /aboutsearch: /commonweal: /404.html 小图标设置找到对应配置文件（next/layout/_partials/head.swig） 修改 href 地址引用即可。 123&#123;% if theme.favicon %&#125; &lt;link rel="shortcut icon" type="image/x-icon" href="/images/logo1.png" /&gt; &#123;% endif %&#125; 标题位置设置 margin设置上下位置text-align 设置左右居中. .posts-expand .post-meta { margin: 3px 0 20px 0; color: #999; font-family: &apos;Lato&apos;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 12px; text-align: left; } .posts-expand .post-meta { margin: 3px 0 60px 0; color: $grey-dark; font-family: $font-family-posts; font-size: 12px; text-align: left; .post-category-list { display: inline-block; margin: 0; padding: 3px; } 搜索功能 到根目录安装 hexo-generator-searchdb $ npm install hexo-generator-searchdb --save 效果如下所示： 参考文档：https://hexo.io/zh-cn/docs/front-matter.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTPS TLS 编译升级 1.0 and 1.2]]></title>
      <url>%2F2016%2F12%2F03%2F1-2%2F</url>
      <content type="text"><![CDATA[先说下背景苹果公司官方宣称2017年 IOS 9 只支持HTTPS TLS 1.2 ,目前系统只支持TLS 1.0 ,无奈之下才升级 因此也有了如下文章。 最初OpenSSL版本123456789101112131415OpenSSL 0.9.8e-fips-rhel5 -bash-3.2$ openssl version -a OpenSSL 0.9.8e-fips-rhel5 01 Jul 2008 built on: Wed Jan 18 10:10:45 EST 2012 platform: linux-x86_64 options: bn(64,64) md2(int) rc4(ptr,int) des(idx,cisc,16,int) blowfish(ptr2) compiler: gcc -fPIC -DOPENSSL_PIC -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DKRB5_MIT - I/usr/kerberos/include -DL_ENDIAN -DTERMIO -Wall -DMD32_REG_T=int -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 - q fexceptions - fstack- protector --param=ssp-buffer-size=4 -m64 -mtune=generic -Wa,--noexecstack -DOPENSSL_USE_NEW_FUNCTIONS -fno-strict- aliasing - DOPENSSL_BN_ASM_MONT -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM OPENSSLDIR: "/etc/pki/tls" engines: dynamic Apache 版本123[root@mtest conf]# /usr/local/apache3/bin/apachectl -version -f /usr/local/apache3/conf/httpd.confServer version: Apache/2.2.26 (Unix)Server built: Nov 15 2016 15:50:10 下载最新版本的openssl and compile 官方描述只有openssl 1.0以上版本才支 TLS1.2, （http://httpd.apache.org/docs/2.2/mod/mod_ssl.html#sslprotocol） 1、wget http://www.openssl.org/source/openssl-1.0.1g.tar.gz 2、tar解压 cd 到 openssl 目录下编译 3、确定 /usr/local/openssl and /usr/local/ssl路径有对应目录 4、./config –prefix=/usr/local/openssl –openssldir=/usr/local/ssl “(注意：不需要替换之前版本的openssl 文件，放到新的目录 避免发生不可预料的问题。)” 5、make 6、make install 检查版本[root@mtest conf]# openssl.bak version OpenSSL 1.0.1g 7 Apr 2014 重新编译Apachecd 到 apache 目录下执行如下命令： 12345 1、./configure --prefix=/usr/local/apache3 --enable-so --enable-proxy --enable-proxy-connect --enable-proxy-http -- enable- proxy-scgi --enable-proxy-ajp --enable-proxy-balancer --enable-rewrite --enable-ssl --with- ssl=/usr/local/openssl/ --enable-cgi --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ 2、make 3、make install 通过openssl 生成key文件认证流程：通过openssl 会生成一个service.key文件，通过service.key文件可以生成service.crt文件，crt文件会上送到证书公司申请ca证书认证,如果公司之前有证书 并且通过第三方公司认证是支持TLS 1.2的 直接拿service.key service.crt放到当相对路径，再通过httpd-ssl-conf 配置相对路径即可. PS: 以下生成的key crt 用于测试，但是 能够满足测试HTTPS 是否支持TLS 1.2。 1234567891011121314151617181920212223 1、cd 到 /usr/local/apache3/conf 目录 2、执行：/usr/local/openssl/bin/openssl genrsa -out server.key 2048 3、执行：/usr/local/openssl/bin/openssl req -new -key server.key -out server.csr You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CHState or Province Name (full name) [Some-State]:chinaLocality Name (eg, city) []:rebbyOrganization Name (eg, company) [Internet Widgits Pty Ltd]:rebbyOrganizational Unit Name (eg, section) []:rebby Common Name (e.g. server FQDN or YOUR name) []:mtest.xxx.com "注意：输入域名地址"Email Address []:haihua@163.comPlease enter the following 'extra' attributesto be sent with your certificate request A challenge password []: "注意：密码直接不要输入 回车。"An optional company name []:rebby 通过openssl生成证书文件12345 /usr/local/openssl/bin/openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crtSignature oksubject=/C=CH/ST=china/L=rebby/O=rebby/OU=rebby/CN=mtest.xxx.com/emailAddress=haihua@163.comGetting Private key 更改配置12345678 1、vim /usr/local/apache3/conf/httpd.conf #Include conf/extra/httpd-ssl.conf "注意：找到这行把 注释去掉 " 2、vim /usr/local/apache3/conf/extra/httpd-ssl.conf 找到 VirtualHost 标签配置自己的域名，以及映射自己具体服务器地址。如下所示：&lt;VirtualHost _default_:443&gt;ServerName mtest.xxx.comProxyPass / http://xx.xx.xxx.11:7001/rebby/ProxyPassReverse / http://xx.0.223.11:7001/rebby/ 启动Apache1234567891011121314 1、[root@mtest bin]# /usr/local/apache3/bin/apachectl start httpd: Could not open configuration file /usr/local/apache/conf/httpd.conf: No such file or directory "注意：执行的时候可能导致文件找不到，我们可以换种方式执行。" 2、 执行： /usr/local/apache3/bin/apachectl -k start -f /usr/local/apache3/conf/httpd.conf[root@mtest bin]# ps -ef | grep apacheroot 24885 1 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24886 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24887 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24888 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24889 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24890 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24891 24885 0 16:15 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.confdaemon 24896 24885 0 16:17 ? 00:00:00 /usr/local/apache3/bin/httpd -k start -f /usr/local/apache3/conf/httpd.conf root 25302 7428 0 18:54 pts/2 00:00:00 grep apache "注意：可以看的出进程已经启动了。" 浏览器测试 通过google 浏览器 F12 –&gt; Security 如下所示：可以看出已经支持TLS 1.2了 ，也可以通过第三方网站测试（https://www.ssllabs.com/ssltest/） 12The connection to this site is encrypted and authenticated using a strong protocol (TLS 1.2), a strong key exchange (ECDHE_RSA), and a strong cipher (AES_128_GCM). 问题总结编译了很多次遇到很多问题，最终上面这个版本编译成功。过程中遇到的问题如下所示： 1、Cannot load /usr/local/apache/modules/mod_ssl.so into server: /usr/local/apache/modules/mod_ssl.so: undefined symbol: EC_KEY_free 编译成功后启动提示 mod_ssl.so已经被内置加载，不需要重新加载wiki有各种解释，不要纠结重新编译。 2、configure: error: ... Error, SSL/TLS libraries were missing or unusable 通过如下命令解决：export LDFLAGS=-ldl 3、 Syntax error on line 56 of /usr/local/apache/conf/extra/httpd-ssl.conf: Invalid command &apos;SSLPassPhraseDialog&apos;, perhaps misspelled or defined by a module not included in the server configuration 没去纠结重新编译Apache. 4、 undefined symbol: ssl_cmd_SSLMutex 解决方法：/usr/local/apache/bin/apxs -i -c -a -D HAVE_OPENSSL=1 -I /usr/include/openssl *.c 5、 undefined symbol: X509_INFO_free 解决方法：undefined symbol: X509_INFO_free 6、 mod_ssl.so: undefined symbol: EC_KEY_free 没去纠结，重新编译 7、rm: cannot remove &apos;libtoolT&apos;: No such file or directory 编译apr 提示libtoolT 文件删除不了，需要在编译文件 找到 grep RM=&apos;$RM&apos;加上 -f 如：RM=&apos;$RM -f&apos; 即可。 Apache 命令/usr/local/apache3/bin/apachectl -k stop -f /usr/local/apache3/conf/httpd.conf 停止 /usr/local/apache3/bin/apachectl -k start -f /usr/local/apache3/conf/httpd.conf 启动 /usr/local/apache3/bin/apachectl -k configtest -f /usr/local/apache3/conf/httpd.conf 检查所有配置文件是否有问题 cat /usr/local/apache3/build/config.nice 查看Apache 加载的内置模板 /usr/local/apache/bin/apxs -c -i mod_ssl.c 重新编译Apache 某个源文件到modules目录]]></content>
    </entry>

    
  
  
</search>
